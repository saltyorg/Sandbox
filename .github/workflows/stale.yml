name: 'Close stale issues and PRs'
on:
  workflow_dispatch:
  schedule:
    - cron: '0 1 * * *'

permissions:
  actions: write
  issues: write
  pull-requests: write

jobs:
  stale:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/stale@v10
        with:
          stale-issue-message: 'This issue is stale because it has been open 30 days with no activity. Remove stale label or comment or this will be closed in 5 days.'
          stale-pr-message: 'This PR is stale because it has been open 45 days with no activity. Remove stale label or comment or this will be closed in 10 days.'
          close-issue-message: 'This issue was closed because it has been stalled for 5 days with no activity.'
          close-pr-message: 'This PR was closed because it has been stalled for 10 days with no activity.'
          days-before-issue-stale: 30
          days-before-pr-stale: 45
          days-before-issue-close: 5
          days-before-pr-close: 10
          stale-issue-label: 'no-issue-activity'
          exempt-issue-labels: 'work-in-progress,no-stale'
          stale-pr-label: 'no-pr-activity'
          exempt-pr-labels: 'work-in-progress,no-stale'
          operations-per-run: 1000

      - name: Reopen stale closed issues that got comments after closure
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            const issueStaleLabel = 'no-issue-activity';
            const prStaleLabel    = 'no-pr-activity';
            const exemptLabels    = new Set(['work-in-progress', 'no-stale']);

            // Keep the scan bounded. Since you run daily, 7â€“30 days is typical.
            const lookbackDays = 30;
            const since = new Date(Date.now() - lookbackDays*24*60*60*1000).toISOString().slice(0,10); // YYYY-MM-DD

            const log = (m) => core.info(m);

            function normalizeLabels(labels) {
              return labels.map(l => (typeof l === 'string' ? { name: l } : l));
            }
            function hasExempt(labels) {
              return labels.some(l => exemptLabels.has(l.name));
            }
            function isBotUser(u) {
              const login = (u?.login || '').toLowerCase();
              return u?.type === 'Bot' || login.endsWith('[bot]') || login === 'github-actions';
            }

            async function searchClosedWithLabel(label) {
              const q = `repo:${owner}/${repo} is:closed label:"${label}" updated:>=${since}`;
              log(`Search: ${q}`);
              const items = [];
              for await (const resp of github.paginate.iterator(
                github.rest.search.issuesAndPullRequests,
                { q, per_page: 100 }
              )) {
                items.push(...resp.data);
              }
              log(`Search results for '${label}': ${items.length}`);
              return items;
            }

            async function getIssue(number) {
              // Works for issues and PRs (PRs are issues in this endpoint)
              return await github.rest.issues.get({ owner, repo, issue_number: number });
            }

            async function hasHumanCommentAfterClosure(number, closedAt) {
              const closedTime = new Date(closedAt).getTime();
              for await (const resp of github.paginate.iterator(
                github.rest.issues.listComments,
                { owner, repo, issue_number: number, per_page: 100, direction: 'desc', sort: 'created' }
              )) {
                for (const c of resp.data) {
                  const t = new Date(c.created_at).getTime();
                  if (t <= closedTime) return false; // sorted newest-first: we're past closure
                  if (!isBotUser(c.user)) return true;
                }
              }
              return false;
            }

            async function reopenAndClear(number, staleLabel) {
              await github.rest.issues.update({ owner, repo, issue_number: number, state: 'open' });
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: number, name: staleLabel });
              } catch (e) {
                if (e.status !== 404) throw e;
              }
            }

            async function process(label, wantPR) {
              const items = await searchClosedWithLabel(label);
              let reopened = 0;

              for (const item of items) {
                const isPR = !!item.pull_request;
                if (isPR !== wantPR) continue;

                const labels = normalizeLabels(item.labels);
                if (hasExempt(labels)) {
                  log(`#${item.number} skip: exempt label present`);
                  continue;
                }
                if (!item.closed_at) {
                  log(`#${item.number} skip: no closed_at`);
                  continue;
                }

                // Get authoritative fields including state_reason
                const full = await getIssue(item.number);
                const stateReason = full.data.state_reason || null;

                // Only treat as "closed by stale" if state_reason indicates "not planned"
                // (this is the deterministic filter replacing your close-message/window heuristic)
                if (stateReason !== 'not_planned') {
                  log(`#${item.number} skip: state_reason=${stateReason}`);
                  continue;
                }

                const commentedAfter = await hasHumanCommentAfterClosure(item.number, item.closed_at);
                if (!commentedAfter) {
                  log(`#${item.number} skip: no human comment after closure`);
                  continue;
                }

                log(`#${item.number} REOPEN: state_reason=not_planned + human comment after closure`);
                await reopenAndClear(item.number, label);
                reopened++;
              }

              log(`Done '${label}' (${wantPR ? 'PRs' : 'issues'}): reopened=${reopened}`);
            }

            await process(issueStaleLabel, false);
            await process(prStaleLabel, true);

